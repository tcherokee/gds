---
// First and Third Party Plugins
import qs from "qs";

// Types and TypeGuards
import type { GameFilters } from "../../../interfaces/common/types";
import type { TAuthor } from "../../../interfaces/users";

// Queries
import { authorPageQs } from "../../../qs/author";

// Helpers
import fetchApi from "../../../lib/strapi";
import { urlTranslate } from "../../../utils/data-store.util";
import {
  slotProviders as slotProvidersResponse,
  getTranslations,
  slotCategories as slotCategoriesResponse,
} from "../../../utils/api-requests";

// Layouts
import MainLayout from "../../layouts/MainLayout.astro";

// Components
import type { TUserGame } from "../../../interfaces/games";
import { gamesQs } from "../../../qs/games";
import GameListBlock from "../../components/blocks/gameListBlock.svelte";
import BlogCard from "../../components/blogs/blogCard.astro";
import CasinoTable from "../../components/casino/casinoTable.astro";
import AuthorCard from "../../components/general/authorCardAlt.astro";

const slug = Astro.params.slug as string;
// Import the QS Query string for custom slugs and prepare it for the API fetch
const query = qs.stringify(authorPageQs(slug.split(".")[0]), {
  encodeValuesOnly: true,
});

// Request to the Fetch Function to get the custom page slugs from the API
const authorPage = await fetchApi<TAuthor[]>({
  endpoint: "users",
  wrappedByKey: "",
  query: `?${query}`,
});

const gamesQueryObj: GameFilters = {
  limit: 18,
  sort: "createdAt:desc",
  page: 1,
  providers: [],
  categories: [],
  author: authorPage[0].slug,
};

const gamesQuery = qs.stringify(gamesQs(gamesQueryObj), {
  encodeValuesOnly: true,
});

const authorGames = await fetchApi<any[]>({
  endpoint: "games",
  wrappedByKey: "data",
  query: `?${gamesQuery}`,
});

const initialGames: TUserGame[] = authorGames.map((elem) => {
  return {
    id: elem.id,
    ...elem.attributes,
    images: {
      url: elem.attributes.images.data.attributes.url,
    },
    provider: {
      slug: elem.attributes.provider.data.attributes.slug,
      title: elem.attributes.provider.data.attributes.title,
    },
  };
});

const translationStore = await getTranslations();
const slotCategories = await slotCategoriesResponse();
const slotProviders = await slotProvidersResponse();

// Setting SITE ID
const SITE_ID = import.meta.env.SITE_ID;

// Create SEO Object
const seo = {
  pageTitle: `${authorPage[0].firstName} ${authorPage[0].lastName}`,
  metaDescription: authorPage[0]?.content1,
  url: `${import.meta.env.FULL_URL}${urlTranslate[SITE_ID as keyof typeof urlTranslate]["author-page"]}/${slug}`,
};

// Create Game Variables Object

const gameBlockObj = {
  __component: "games.games-carousel",
  numberOfGames: 18,
  sortBy: "Newest",
  showGameFilterPanel: false,
  showGameMoreButton: true,
  gameProviders: [],
  gameCategories: [],
};

// Truncate and Clean Blog Object
const truncatedBlogObj = authorPage[0].blogs.map((item: any) => {
  if (item && item.content1) {
    // Remove HTML tags
    const plainText = item.content1.replace(/<[^>]*>/g, "");

    // Split into words and truncate to 25 words
    const words = plainText.split(/\s+/).slice(0, 25).join(" ");

    // Update the content1 field
    item.content1 = words;
  } else if (item && item.title) {
    // Split the title into words and truncate to 10 words
    const truncatedTitle = item.title.split(/\s+/).slice(0, 10).join(" ");

    // Update the title field
    item.title = truncatedTitle;
  }
  return item;
});

// Caching System
const surrogateKeys = [];

// Page-specific tags
surrogateKeys.push("page:authordetail");
surrogateKeys.push(`author:${authorPage[0]?.id}`);
surrogateKeys.push(`authorslug:${slug}`);

// Content-type tags
surrogateKeys.push("type:authorpage");

// Add content-specific tags based on what's shown on the page
if (initialGames && initialGames.length > 0) {
  surrogateKeys.push("content:games");

  // Add game count tag
  surrogateKeys.push(`gamecount:${Math.floor(initialGames.length / 5) * 5}`); // Round to nearest 5

  // Track game providers represented on this page
  const gameProviders = [
    ...new Set(initialGames.map((game) => game.provider?.slug).filter(Boolean)),
  ];

  if (gameProviders.length > 0) {
    gameProviders.forEach((provider) => {
      if (provider) {
        surrogateKeys.push(`provider:${provider}`);
      }
    });
  }

  // Add individual game IDs for selective invalidation
  initialGames.forEach((game) => {
    surrogateKeys.push(`game:${game.id}`);
  });
}

// Add blog-related tags if blogs are present
if (authorPage[0]?.blogs && authorPage[0]?.blogs.length > 0) {
  surrogateKeys.push("content:blogs");

  // Add blog count tag
  surrogateKeys.push(`blogcount:${authorPage[0].blogs.length}`);

  // Add individual blog IDs for selective invalidation
  authorPage[0].blogs.forEach((blog) => {
    if (blog.id) {
      surrogateKeys.push(`blog:${blog.id}`);
    }
  });
}

// Add casino-related tags if casinos are present
if (authorPage[0]?.casinos && authorPage[0]?.casinos.length > 0) {
  surrogateKeys.push("content:casinos");

  // Add casino count tag
  surrogateKeys.push(`casinocount:${authorPage[0].casinos.length}`);

  // Add individual casino IDs for selective invalidation
  authorPage[0].casinos.forEach((casino) => {
    if (casino.id) {
      surrogateKeys.push(`casino:${casino.id}`);
    }
  });
}

// Add version or timestamp tag to allow for complete cache refresh when needed
const contentTimestamp = authorPage[0]?.updatedAt || Date.now();
surrogateKeys.push(`version:${contentTimestamp}`);

// Set Surrogate-Key header for GCP CDN cache invalidation
Astro.response.headers.set("Surrogate-Key", surrogateKeys.join(" ")); // Space-separated list

// Generate a proper ETag based on content
// Create a content signature from key data that would trigger a cache invalidation when changed
const contentSignature = JSON.stringify({
  // Include critical content identifiers that should trigger cache invalidation
  authorId: authorPage[0]?.id,
  slug: slug,
  firstName: authorPage[0]?.firstName,
  lastName: authorPage[0]?.lastName,
  updatedAt: contentTimestamp,
  gamesCount: initialGames?.length || 0,
  blogsCount: authorPage[0]?.blogs?.length || 0,
  casinosCount: authorPage[0]?.casinos?.length || 0,
  // Include IDs for the most recent items in each category to detect updates
  recentGameIds: initialGames?.slice(0, 5).map((game) => game.id),
  recentBlogIds: authorPage[0]?.blogs?.slice(0, 5).map((blog) => blog.id),
  recentCasinoIds: authorPage[0]?.casinos
    ?.slice(0, 5)
    .map((casino) => casino.id),
  // Include content summary
  contentSummary: authorPage[0]?.content1?.substring(0, 100),
  seo: {
    title: `${authorPage[0]?.firstName} ${authorPage[0]?.lastName}`,
    description: authorPage[0]?.content1?.substring(0, 150),
  },
});

// Generate a hash of the content signature for the ETag
// In a production environment, you might want to use a more sophisticated hashing function
const contentHash = Array.from(
  new Uint8Array(new TextEncoder().encode(contentSignature))
)
  .reduce((hash, byte) => ((hash << 5) - hash + byte) | 0, 0)
  .toString(36);

// Create and set a proper ETag (weak validator with W/ prefix is appropriate for HTML content)
const etagValue = `W/"${contentHash}"`;
Astro.response.headers.set("ETag", etagValue);

// Check for If-None-Match header to enable 304 responses
const ifNoneMatch = Astro.request.headers.get("If-None-Match");
if (ifNoneMatch === etagValue) {
  return new Response(null, {
    status: 304,
    headers: {
      ETag: etagValue,
      "Cache-Control":
        "public, max-age=86400, s-maxage=604800, stale-while-revalidate=3600, stale-if-error=259200",
      "Surrogate-Key": surrogateKeys.join(" "),
      "Surrogate-Control": "max-age=604800",
      "Last-Modified": new Date(contentTimestamp).toUTCString(),
    },
  });
}

// Set aggressive caching
// Browser cache: 1 day
// CDN cache: 7 days (via s-maxage)
// Stale-while-revalidate: 1 hour
// Stale-if-error: 3 days
Astro.response.headers.set(
  "Cache-Control",
  "public, max-age=86400, s-maxage=604800, stale-while-revalidate=3600, stale-if-error=259200"
);

// Optional: Add Surrogate-Control header (might be useful for other CDNs)
Astro.response.headers.set("Surrogate-Control", "max-age=604800");

// Optional: Set cache validation headers
const lastModifiedDate = new Date(contentTimestamp).toUTCString();
Astro.response.headers.set("Last-Modified", lastModifiedDate);

---

<MainLayout seoData={seo}>
  <div class="relative after:content-[''] bg-blog-list-bkg">
    <div class="w-full pt-5 px-3 author-upper-section pb-[65px]">
      <div class="xl:container">
        <div>
          <AuthorCard data={authorPage[0]} isFlat={true} {translationStore} />
        </div>

        {
          authorPage[0]?.games.length > 0 && (
            <>
              <div class="">
                <h2 class="text-white">Ultimi giochi recensiti dall'autore</h2>
              </div>
              <div class="mt-5 glass-wrapper">
                <GameListBlock
                  data={gameBlockObj}
                  {initialGames}
                  author={authorPage[0].slug}
                  translations={translationStore}
                  {slotProviders}
                  {slotCategories}
                  client:load
                />
              </div>
            </>
          )
        }
      </div>
    </div>
  </div>
  <div class="relative xl:container px-2 pb-5">
    {
      authorPage[0]?.blogs.length > 0 && (
        <div class="mt-6 md:mt-8">
          <h2 class="!mb-5 !md:mb-6">Articoli recenti dell'autore</h2>
          <div class="grid md:grid-cols-3 gap-3 md:gap-8">
            <BlogCard data={truncatedBlogObj} {translationStore} />
          </div>
        </div>
      )
    }
    {
      authorPage[0]?.casinos.length > 0 && (
        <div class="mt-5">
          <h2>Casino recensiti dall'autore</h2>
          <div class="mb-5">
            <CasinoTable casinos={authorPage[0]?.casinos} {translationStore} />
          </div>
        </div>
      )
    }
  </div>
  <style lang="scss">
    .author-upper-section {
      background: var(
        --Gradients-BG-Blue,
        linear-gradient(
          180deg,
          theme("colors.background-top-gradient") 0%,
          theme("colors.background-bottom-gradient") 100%
        )
      );
    }
  </style>
</MainLayout>
