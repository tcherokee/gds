---
import qs from "qs";
import fetchApi from "../../../lib/strapi";
import MainLayout from "../../layouts/MainLayout.astro";
import { urlTranslate } from "../../../utils/data-store.util";
import { blogmetaQs } from "../../../qs/blog-meta";
import { blogcardQs } from "../../../qs/blog-cards";
import type { BlogList } from "../../../interfaces/blog";
import BlogListBlock from "../../components/blocks/blogListBlock.astro";
import Pagination from "../../components/helpers/pagination.astro";
import { getTranslations } from "../../../utils/api-requests";

const translationStore = await getTranslations();

const query = qs.stringify(blogcardQs(12, 1), { encodeValuesOnly: true });
const metaQuery = qs.stringify(blogmetaQs(), { encodeValuesOnly: true });

const blogCards = await fetchApi<BlogList>({
  endpoint: "blogs",
  isPaginated: true,
  query: `?${query}`,
});

const layoutData = await fetchApi<any>({
  endpoint: "layout",
  wrappedByKey: "data",
  query: `?${metaQuery}`,
});

let siteID = import.meta.env.SITE_ID;
let siteURL = import.meta.env.FULL_URL;
let canonical = `${siteURL}${urlTranslate[siteID as keyof typeof urlTranslate]["blog-index"]}`;

//set page seo data
let seo = {
  pageTitle: layoutData?.attributes?.blogMeta?.blogTitle,
  metaDescription: layoutData?.attributes?.blogMeta?.blogDescription,
  url: canonical,
};

// Cahe System
const surrogateKeys = [];

// Page-specific tags
surrogateKeys.push("page:blogindex");
surrogateKeys.push("type:bloglist");

// Add content-specific tags
surrogateKeys.push("content:blogs");

// Add pagination tag to help with pagination-specific invalidation
const currentPage = blogCards?.meta?.pagination?.page || 1;
surrogateKeys.push(`page:${currentPage}`);

// Add blog count tag - useful for detecting when new blogs are added
const blogCount = blogCards?.meta?.pagination?.total || 0;
surrogateKeys.push(`blogcount:${Math.floor(blogCount / 10) * 10}`); // Round to nearest 10

// Add blog ID tags for the current page
// This allows invalidation when specific blogs are updated
if (blogCards.data && blogCards.data.length > 0) {
  // Create a tag with all blog IDs on this page
  const blogIds = blogCards.data.map((blog) => blog.id).join("-");
  surrogateKeys.push(`blogs:${blogIds}`);

  // Add individual blog tags
  blogCards.data.forEach((blog) => {
    surrogateKeys.push(`blog:${blog.id}`);
  });

  // Track most recent blog update time for versioning
  const latestBlogUpdate = blogCards.data.reduce((latest, blog) => {
    const blogDate = new Date(
      blog.attributes?.updatedAt || blog.attributes?.createdAt || 0
    ).getTime();
    return blogDate > latest ? blogDate : latest;
  }, 0);

  if (latestBlogUpdate > 0) {
    surrogateKeys.push(
      `blogupdated:${new Date(latestBlogUpdate).toISOString().slice(0, 10)}`
    );
  }
}

// Add tag for layout data
if (layoutData?.attributes?.blogMeta) {
  surrogateKeys.push("content:blogmeta");
}

// Add version or timestamp tag to allow for complete cache refresh when needed
const contentTimestamp = Date.now();
surrogateKeys.push(`version:${contentTimestamp}`);

// Set Surrogate-Key header for GCP CDN cache invalidation
Astro.response.headers.set("Surrogate-Key", surrogateKeys.join(" ")); // Space-separated list

// Generate a proper ETag based on content
// Create a content signature from key data that would trigger a cache invalidation when changed
const contentSignature = JSON.stringify({
  // Include critical content identifiers that should trigger cache invalidation
  page: currentPage,
  blogCount: blogCount,
  pageCount: blogCards?.meta?.pagination?.pageCount || 0,
  blogIds: blogCards.data?.map((blog) => blog.id) || [],
  latestUpdate:
    blogCards.data?.length > 0
      ? Math.max(
          ...blogCards.data.map((blog) =>
            new Date(
              blog.attributes?.updatedAt || blog.attributes?.createdAt || 0
            ).getTime()
          )
        )
      : 0,
  seo: {
    title: layoutData?.attributes?.blogMeta?.blogTitle,
    description: layoutData?.attributes?.blogMeta?.blogDescription,
  },
});

// Generate a hash of the content signature for the ETag
// In a production environment, you might want to use a more sophisticated hashing function
const contentHash = Array.from(
  new Uint8Array(new TextEncoder().encode(contentSignature))
)
  .reduce((hash, byte) => ((hash << 5) - hash + byte) | 0, 0)
  .toString(36);

// Create and set a proper ETag (weak validator with W/ prefix is appropriate for HTML content)
const etagValue = `W/"${contentHash}"`;
Astro.response.headers.set("ETag", etagValue);

// Check for If-None-Match header to enable 304 responses
const ifNoneMatch = Astro.request.headers.get("If-None-Match");
if (ifNoneMatch === etagValue) {
  return new Response(null, {
    status: 304,
    headers: {
      ETag: etagValue,
      "Cache-Control":
        "public, max-age=86400, s-maxage=604800, stale-while-revalidate=3600, stale-if-error=259200",
      "Surrogate-Key": surrogateKeys.join(" "),
      "Surrogate-Control": "max-age=604800",
      "Last-Modified": new Date(contentTimestamp).toUTCString(),
    },
  });
}

// Set aggressive caching
// Browser cache: 1 day
// CDN cache: 7 days (via s-maxage)
// Stale-while-revalidate: 1 hour
// Stale-if-error: 3 days
Astro.response.headers.set(
  "Cache-Control",
  "public, max-age=86400, s-maxage=604800, stale-while-revalidate=3600, stale-if-error=259200"
);

// Optional: Add Surrogate-Control header (might be useful for other CDNs)
Astro.response.headers.set("Surrogate-Control", "max-age=604800");

// Optional: Set cache validation headers
const lastModifiedDate = new Date(contentTimestamp).toUTCString();
Astro.response.headers.set("Last-Modified", lastModifiedDate);
---

<MainLayout seoData={seo}>
  <div class="bg-blog-list-bkg">
    <div class="xl:container px-2 pb-5 pt-4">
      <div class="xl:container px-2 pb-5 pt-4">
        <!-- <div class="grid grid-cols-1 md:grid-cols-3 gap-5"> -->
        <BlogListBlock data={blogCards.data} {translationStore} />
        <!-- </div> -->

        <Pagination
          currPage={blogCards?.meta?.pagination?.page}
          pageCount={blogCards?.meta?.pagination?.pageCount}
          path={urlTranslate[siteID as keyof typeof urlTranslate]["blog-pages"]}
          {translationStore}
        />
      </div>
    </div>
  </div>
</MainLayout>
